# 走入并行世界

## 几个相关的基础概念

### 1. 同步和异步

同步：同步方法一旦开始，调用者必须等待方法调用返回之后才能够继续进行后续操作（买家去超市买空调：购物开始-选购-付款-超市送货上门-开始使用空调）

异步：通常会在另一个线程中真实的运行，不会妨碍到调用者的工作（买家在网上买空调：购物开始-选购-付款（此时买家的任务已完成）-快递送货上门-开始使用空调）



### 2. 并发和并行

并发：偏重于多个任务**交替进行**，但多个任务之间也可能是串行的

并行：真正意义上的“同时执行”

单核CPU只能执行并发操作，真正意义上的并行只会发生在多核CPU中（CPU一次只能执行一条指令）



### 3. 临界区

表示一种公共资源（共享数据），可以被多个线程调用。但是每一次只能够有一个线程使用它，如果已经有线程使用，则其他线程必须等待



### 4. 阻塞和非阻塞

阻塞：一个线程使用了临界区资源，其他线程就需要等待，导致进程挂起，这种状态叫做阻塞。如果占用资源的线程一直不肯释放资源，那么其他所有阻塞在这个了临界区上的线程都无法工作

非阻塞：与阻塞相反，表示没有一个线程可以妨碍其他线程执行，所有线程都在继续向前执行。



### 5. 死锁、饥饿和活锁

死锁：所有线程都在互相等待对方释放资源，造成互相等待的死锁

饥饿：指线程由于各种原因（如线程优先级太低，导致优先级高的线程不断抢占资源导致优先级低线程无法工作）无法得到资源从而无法工作，或者线程一直占用资源导致其他线程无法工作

活锁：多个线程互相谦让资源导致谁也执行不了的情况



## 并发级别

基本上可分为：阻塞、无饥饿、无障碍、无锁、无等待几种



### 阻塞
使用**synchronized**关键字或者**重入锁**，得到的就是阻塞的线程
无论是使用**synchronized**关键字或者**重入锁**，都会试图在执行后续代码之前，得到临界区的锁，如果得不到，则会挂起等待，直到占有了所需资源为止



### 无饥饿

如果线程之间是有优先级的，则线程调度时会偏向优先级高的线程。

对于非公平的锁，系统允许优先级高的线程插队，则优先级低的线程会发生饥饿现象

对于公平的锁，满足先来后到，那么饥饿现象就不会发生



### 无障碍

无障碍是最弱的一种非阻塞调度。如果两个线程无障碍执行，则表示不会受到临界区资源的限制

如果检测到临界区资源被不同线程同时修改的情况，则会回滚自己做的修改，保证数据安全



























































