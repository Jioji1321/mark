# 走入并行世界

## 几个相关的基础概念

### 1. 同步和异步

同步：同步方法一旦开始，调用者必须等待方法调用返回之后才能够继续进行后续操作（买家去超市买空调：购物开始-选购-付款-超市送货上门-开始使用空调）

异步：通常会在另一个线程中真实的运行，不会妨碍到调用者的工作（买家在网上买空调：购物开始-选购-付款（此时买家的任务已完成）-快递送货上门-开始使用空调）



### 2. 并发和并行

并发：偏重于多个任务**交替进行**，但多个任务之间也可能是串行的

并行：真正意义上的“同时执行”

单核CPU只能执行并发操作，真正意义上的并行只会发生在多核CPU中（CPU一次只能执行一条指令）



### 3. 临界区

表示一种公共资源（共享数据），可以被多个线程调用。但是每一次只能够有一个线程使用它，如果已经有线程使用，则其他线程必须等待



### 4. 阻塞和非阻塞

阻塞：一个线程使用了临界区资源，其他线程就需要等待，导致进程挂起，这种状态叫做阻塞。如果占用资源的线程一直不肯释放资源，那么其他所有阻塞在这个了临界区上的线程都无法工作

非阻塞：与阻塞相反，表示没有一个线程可以妨碍其他线程执行，所有线程都在继续向前执行。



### 5. 死锁、饥饿和活锁

死锁：所有线程都在互相等待对方释放资源，造成互相等待的死锁

饥饿：指线程由于各种原因（如线程优先级太低，导致优先级高的线程不断抢占资源导致优先级低线程无法工作）无法得到资源从而无法工作，或者线程一直占用资源导致其他线程无法工作

活锁：多个线程互相谦让资源导致谁也执行不了的情况



## 并发级别

基本上可分为：阻塞、无饥饿、无障碍、无锁、无等待几种



### 阻塞
使用**synchronized**关键字或者**重入锁**，得到的就是阻塞的线程
无论是使用**synchronized**关键字或者**重入锁**，都会试图在执行后续代码之前，得到临界区的锁，如果得不到，则会挂起等待，直到占有了所需资源为止



### 无饥饿

如果线程之间是有优先级的，则线程调度时会偏向优先级高的线程。

对于非公平的锁，系统允许优先级高的线程插队，则优先级低的线程会发生饥饿现象

对于公平的锁，满足先来后到，那么饥饿现象就不会发生



### 无障碍

无障碍是最弱的一种非阻塞调度。如果两个线程无障碍执行，则表示不会受到临界区资源的限制

如果检测到临界区资源被不同线程同时修改的情况，则会回滚自己做的修改，保证数据安全



## JMM（Java内存模型）

### 原子性

指的是一个操作是不可中断的，即使有多个线程同时执行，一个操作一旦开始，就不会受到其他线程的干扰

对于32位的系统来说，long类型不是原子性的（long有64位），如果两个线程同时对long进行写入读取操作的话，由于并行的关系，数字被写乱了，或者读的时候串位了



### 可见性

指的是当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改

在串行程序中这个问题不存在，但是在并行程序中这个问题可能存在

CPU A中的线程修改了共享变量的值然后将其结果保存在寄存器或者缓存中（缓存优化或者硬件优化），CPU B中的线程变量再去读取的时候可能读到修改之前的值



### 有序性

在并发时，程序的执行可能会出现乱序

有序性问题的原因是因为程序在执行时，可能会进行指令重排，重排后指令的顺序和与按顺序未必一致



### 哪些指令不能进行重排？

- 程序顺序原则：一个线程内保证语义的串行性
- volatile规则：volatile变量的写，先发生于读，这保证了volatile变量的可见性
- 锁规则：解锁（unlock）必然发生在随后的加锁（lock）前
- 传递性：A先于B，B先于C，则A必然先于C
- 线程的start()方法先于他的每一个动作
- 线程的所有操作先于线程的终结（Thread.join()）
- 线程的中断(interrupt())先于被中断线程的代码
- 对象的构造函数执行、结束先于finalize()方法



# Java并行程序基础

进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础















































